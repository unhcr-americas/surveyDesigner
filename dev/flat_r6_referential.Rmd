---
title: "Class R6 for the referential"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
library(readxl)
library(dplyr)
library(purrr)

```

# r6_referential

A referential is initially created through the import from an excel file. 

For each Operational purpose (Household Survey, Flow Monitoring, Key Informants...), there's a distinct referential.

This file at first defines the mapping between:  

  * Indicators;
  * Target population;
  * Disaggregation variables;
  * Survey Variables;
  * Survey modalities, aka the choices.

The filtering of the referential should take in account the order/sequence of questions and modules. 

A specific method is implemented to separate our file with begin and end group

```{r function-r6_referential}
#' Referential class is a class to load, check and manipulate the XLSForm 
#' @importFrom R6 R6Class
#' 
#' @export

Referential <- R6::R6Class(classname = "Referential",
                           public = list(
                             #' @description 
                             #' read the xlsx for each sheet and return a named list
                             #' @param path path to the file with the full referential
                             #' 
                             #' @importFrom readxl excel_sheets read_xlsx
                             #' 
                             #' @return named list
                             initialize = function(path){
                               # Define path
                               self$path <- path
                               
                               # Get sheets of xlsx
                               sheets <- names_of_sheet(path)
                               
                               # Read the xlsx file 
                               data <- lapply(
                                 sheets, 
                                 function(x){
                                   read_xlsx(path = path, sheet = x)}) |>
                                      setNames(nm = sheets)
                               # TODO checking survey and other sheets
                               
                               # survey have to be a xlsform

                               if(!contains_groups(data$survey)){
                                 stop("the sheet 'survey' doesn't includes groups - i.e. questions organised as module")
                               }
                               
                               self$data <- data
                               
                               # Get groups 
                               
                               self$get_groups()
                             },
                             #' @field data named list for the referential file
                             data = list(),
                             #' @field by_groups survey modules separated by begin and end to manipulate data
                             by_groups = list(),
                             #' @field path path for the xlsx file
                             path  = character(0),
                             #' @description get data by groups of begin and end
                             get_groups = function(){
                               self$by_groups <- get_groups(self$data$survey)
                               
                               message("result is store in `by_groups` sub-element")
                             }
                           ),
                           private = list(
                             
                           )
)
```

```{r development-test}
ref <- Referential$new(
  path = system.file("SurveyDesigner_Referential.xlsx", package = "surveyDesigner") 
)
```


```{r examples-r6_referential}
ref <- Referential$new(
  path = system.file("SurveyDesigner_Referential.xlsx", package = "surveyDesigner") 
)

head(ref$data$survey)

# Example by groups
ref$by_groups$group_intro
```

```{r tests-r6_referential}
test_that("r6_referential works", {
  ref <- Referential$new(
    path = system.file("SurveyDesigner_Referential.xlsx", package = "surveyDesigner") 
  )
  
  expect_true( inherits(ref, "R6") )
  
  expect_error(
    Referential$new(
      path = "not_good_sheet.xlsx" 
    )
  )
  
  expect_error(
    Referential$new(
      path = "wt_xlsform_in_survey.xlsx" 
    )
  )

})
```


# Utils for referential manipulation

Utilities functions are created to ensure the full integrity of the referential

## Utilities in relation with xlsform

 * `names_of_sheet` The referential file in excel should includes all required worksheet. When loading the referential - it should comply with xlsform and  further referential-specific expected parameters - see - also https://github.com/XLSForm/pyxform
 
 * `contains_groups` the survey worksheet should include groups to bring together questions
 
 * `get_groups` utilities to pull groups from the survey worksheet
 
 * `get_choices_for_question` utilities to pull all choices from select_one and select_all functions
 
```{r function-utils_xlsform}
survey_designer <- new.env()

assign(
  "names_sheets", 
  c("referential_type",
    "survey",
    "choices",
    "indicator",
    "indicator_survey",
    "indicator_choices",
    "indicator_population",
    "indicator_disaggregation"), 
  envir = survey_designer)

assign(
  "names_referential_type", 
  c("referential_type", "type", "description" ), 
  envir = survey_designer)

assign(
  "names_survey", 
  c("referential_id",  "type" , "name",                     
  "label", "hint", "required",                 
 "required_message",  "constraint",  "constraint_message" ,      
 "relevant" ,  "appearance" , "calculation",              
 "trigger" ,  "parameters" , "repeat_count" ,            
 "default",   "read_only"  , "choice_filter" ,           
  #"media::image" ,
  #"$given_name",
 "contextualize" ,           
  "contextualize_instruction", "block",  "block_sequence" ,          
  "sequence",  "mode" ,  "check"   ,                 
  "accuracy",  "chapter", "subchapter" ,              
  "labelReport", "hintReport", "keyword"  ), 
  envir = survey_designer)

assign(
  "names_choices", 
  c( "referential_id",    "list_name",     "name" ,                    
     "label" ,  "order" , "contextualize"  ,          
     "contextualize_instruction", "labelReport"  ), 
  envir = survey_designer)

assign(
  "names_indicator", 
  c( "referential_id", "type" ,   "name",    "labelReport" , "hintReport" , "list_name",     
  "repeatvar",      "ind_type",  "sequence" ,  "block",   "chapter",    "subchapter" ,   
 "calculation" ,  "unit"  ,    "accuracy",   "mode_CAPI",   "mode_CATI"  ,   
 "mode_CAWI",   "metadata",   "link" ,    "keyword" 
  ), 
  envir = survey_designer)

assign(
  "names_indicator_survey", 
  c( "referential_id", "name" , "name_survey" ), 
  envir = survey_designer)

assign(
  "names_indicator_choices", 
  c( "referential_id", "name" , "name_choices"   ), 
  envir = survey_designer)

assign(
  "names_indicator_population", 
  c( "referential_id", "name",  "name_poulation"  ), 
  envir = survey_designer)

assign(
  "names_indicator_disaggregation", 
  c( "referential_id",  "name" ,  "name_dissagregation" ), 
  envir = survey_designer)
 
#' function to check name of sheets
#'
#' @param path path to the xlsform
#' 
#' @importFrom readxl excel_sheets
#' @importFrom stats setNames
#'
#' @noRd
names_of_sheet <- function(path){
  sheets <- excel_sheets(path)
  if(all(sheets == get("names_sheets", envir = survey_designer))){
    return(sheets)
  } else {
    stop("Problem with the name of sheets in the xls file used to load the referential")
  }
  
  # Read the xlsx file 
  data <- lapply( sheets,  function(x){ read_xlsx(path = path, sheet = x)}) |>
                  setNames(nm = sheets)

  referential_type <- names(data$referential_type)
  if(all(referential_type  %in% get("names_referential_type", envir = survey_designer)) ){
    return(referential_type)
  } else {
    stop("Problem with the name of sheet for referential_type")
  }
  
  survey <- names(data$survey)
  if(all(survey  %in% get("names_survey", envir = survey_designer)) ){
    return(survey)
  } else {
    stop("Problem with the name of sheet for survey")
  }
    
  choices <- names(data$choices)
  if(all(choices  %in% get("names_choices", envir = survey_designer)) ){
    return(choices)
  } else {
    stop("Problem with the name of sheet for choices")
  }
      
  indicator <- names(data$indicator)
  if(all(indicator  %in% get("names_indicator", envir = survey_designer)) ){
    return(indicator)
  } else {
    stop("Problem with the name of sheet for indicator")
  }
        
  indicator_survey <- names(data$indicator_survey)
  if(all(indicator_survey  %in% get("names_indicator_survey", envir = survey_designer)) ){
    return(indicator_survey)
  } else {
    stop("Problem with the name of sheet for indicator_survey")
  }
          
  indicator_choices <- names(data$indicator_choices)
  if(all(indicator_choices  %in% get("names_indicator_choices", envir = survey_designer)) ){
    return(indicator_choices)
  } else {
    stop("Problem with the name of sheet for indicator_choices")
  }
            
  indicator_population <- names(data$indicator_population)
  if(all(indicator_population  %in% get("names_indicator_population", envir = survey_designer)) ){
    return(indicator_population)
  } else {
    stop("Problem with the name of sheet for indicator_population")
  }
              
  indicator_disaggregation <- names(data$indicator_disaggregation)
  if(all(indicator_disaggregation  %in% get("names_indicator_disaggregation", envir = survey_designer)) ){
    return(indicator_disaggregation)
  } else {
    stop("Problem with the name of sheet for indicator_disaggregation")
  }
}


#' Get groups form begin and end into a list with data and information
#' 
#' @param data data from the survey sheet
#'
#' @importFrom purrr map2 set_names map
#' @importFrom dplyr slice filter
#' 
#' @return list
#' 
get_groups <- function(data){
  # only on survey
  begin_start <- grep(x = data[["type"]], "begin_")
  end_stop <- grep(x = data[["type"]], "end_")
  
  if(length(begin_start) != length(end_stop)){
    stop("Miss one begin or stop in the data")
  }
  
  if(!all(begin_start < end_stop)){
    stop("One begin is before a end")
  }
  
  by_begin_end <- map2(begin_start, end_stop,
                              function(x,y){
                                
                                data_to_get <- data %>% 
                                  slice(x:y)
                                by_groups <- list(data = data_to_get %>%
                                                    filter(!type %in% c("begin_group", "end_group")),
                                                  information = data_to_get %>%
                                                    filter(type %in% c("begin_group", "end_group"))
                                )
                                # names(by_groups) <- by_groups[["information"]][["name"]]
                                
                                by_groups
                              }) %>% 
  purrr::set_names(nm = purrr::map(., ~ .x[["information"]][["name"]][1]))

 return(by_begin_end)
}

#' Get choices for one question
#'
#' @param survey data from the choices sheet
#' @param full_name the full name (i.e. concatenating groups) for the variable
#'
#' @importFrom dplyr filter select contains
#'
#' @return a data.frame to join
get_choices_for_question <- function(survey, full_name){
  survey %>% 
    filter(list_name == full_name) %>% 
    select(list_name, name, label)
}

#' function to find if we manipulate a xlsform
#'
#' @param data data of the survey
#'
#' @noRd


contains_groups <- function(data){
  any(grepl(x = data[["type"]], pattern = 'begin_group|begin_repeat|end_group|end_repeat'))
}


```

```{r development-utils, eval = FALSE}

data <- ref$data$survey
# names(ref$data)
# names(ref$data$referential_type)
# names(ref$data$survey)
# names(ref$data$choices)
# names(ref$data$indicator)
# names(ref$data$indicator_survey)
# names(ref$data$indicator_choices)
# names(ref$data$indicator_population)
# names(ref$data$indicator_disaggregation)

begin_start <- grep(x = , "begin_")
end_stop <- grep(x = data[["type"]], "end_")

if(length(begin_start) != length(end_stop)){
  stop("Miss one begin or stop in the data")
}

if(!all(begin_start < end_stop)){
  stop("One begin is before a end")
}

by_begin_end <- purrr::map2(begin_start, end_stop,
                            function(x,y){
                              
                              data_to_get <- data %>% 
                                slice(x:y)
                              by_groups <- list(data = data_to_get %>%
                                                  filter(!type %in% c("begin_group", "end_group")),
                                                information = data_to_get %>%
                                                  filter(type %in% c("begin_group", "end_group"))
                              )
                              # names(by_groups) <- by_groups[["information"]][["name"]]
                              
                              by_groups
                            }) %>% 
  purrr::set_names(nm = purrr::map(., ~ .x[["information"]][["name"]][1]))


```

```{r tests-utils_xlsform}
test_that("utils_xlsform works", {
  
  expect_true(inherits(get_groups, "function")) 
  
  ref <- Referential$new(
            path = system.file("SurveyDesigner_Referential.xlsx", package = "surveyDesigner") 
          )
  result <- get_groups(ref$data$survey)
  expect_named(result[[1]], c("data", "information"))
  expect_type(result, "list")
  
  
  expect_true(inherits(get_choices_for_question, "function"))
  get_choices <- get_choices_for_question(ref$data$choices, "pop_groups")
  
  expect_type(get_choices, "list")

})
```

## Utilities in relation with indicators mapping
 
 * `has_variables_for_indicators` If an indicator is defined it should map with at least one variable from the survey worksheet
 
 * `indicator_linked_population` An indicator should map with at least one population
 
 * `population_linked_indicator` If a relation between one population and one indicator is recorded, the indicator should also be defined in the indicator frame
 
 * `indicator_linked_variable` If an indicator is defined to map with variables from the survey worksheet, then all those variables should actually be present in the survey frame
    
    
    
```{r function-utils_indicator_map}
#' function to check that if an indicator is defined it should map with at
#'   least one variable from the survey worksheet
#'
#' @param path path to the xlsform
#' 
#' @importFrom readxl excel_sheets
#'
#' @noRd
has_variables_for_indicators <- function(path){
           
  # if(all(indicator_disaggregation  %in% get("names_indicator_disaggregation", envir = survey_designer)) ){
  #   return(indicator_disaggregation)
  # } else {
  #   stop("Problem with the name of sheet for indicator_disaggregation")
  # }
}

#' function to check that an indicator should map with at least one population
#'
#' @param path path to the xlsform
#' 
#' @importFrom readxl excel_sheets
#'
#' @noRd
indicator_linked_population <- function(path){
           
  # if(all(indicator_disaggregation  %in% get("names_indicator_disaggregation", envir = survey_designer)) ){
  #   return(indicator_disaggregation)
  # } else {
  #   stop("Problem with the name of sheet for indicator_disaggregation")
  # }
}

#' function to check that if a relation between one population and one indicator
#'  is recorded, the indicator should also be defined in the indicator frame
#'
#' @param path path to the xlsform
#' 
#' @importFrom readxl excel_sheets
#'
#' @noRd
population_linked_indicator <- function(path){
           
  # if(all(indicator_disaggregation  %in% get("names_indicator_disaggregation", envir = survey_designer)) ){
  #   return(indicator_disaggregation)
  # } else {
  #   stop("Problem with the name of sheet for indicator_disaggregation")
  # }
}

#' function to check that if an indicator is defined to map with variables 
#' from the survey worksheet, then all those variables should actually be 
#' present in the survey frame
#'
#' @param path path to the xlsform
#' 
#' @importFrom readxl excel_sheets
#'
#' @noRd
indicator_linked_variable <- function(path){
           
  # if(all(indicator_disaggregation  %in% get("names_indicator_disaggregation", envir = survey_designer)) ){
  #   return(indicator_disaggregation)
  # } else {
  #   stop("Problem with the name of sheet for indicator_disaggregation")
  # }
}
 

```
 
 
```{r development-utils, eval = FALSE}
 

```

  
  
```{r tests-utils_indicator_map}
test_that("utils_indicator_map works", {
  expect_true(inherits(has_variables_for_indicators, "function"))
  
  expect_true(inherits(indicator_linked_population, "function"))
  
  expect_true(inherits(population_linked_indicator, "function"))
  
  expect_true(inherits(indicator_linked_variable, "function"))
})
```



  

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(
  flat_file = "dev/flat_r6_referential.Rmd", 
  vignette_name = "Class R6 for the referential"
  )
```

